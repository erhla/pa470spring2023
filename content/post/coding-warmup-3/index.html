---
title: "Coding Warmup 3"
date: 2023-02-02
categories: ["R"]
tags: ["warmup"]
publishdate: 2023-01-26
---



<p>This assignment is ungraded. I encourage you to review the problems to see if (1) you know how to do them or (2) if you know how to google how to do it. If either path forward escapes you, I suggest that you complete this assignment.</p>
<div id="part-0-optional" class="section level1">
<h1>Part 0 (optional)</h1>
<p>Accept the invitation to GitHub Classroom <a href="https://classroom.github.com/a/vNnoDD6X">here</a>. Commit your work as you go along.</p>
</div>
<div id="part-1" class="section level1">
<h1>Part 1</h1>
<p>Exercise 7.2.3 from Data Science for Public Policy. Data can be found <a href="https://raw.githubusercontent.com/DataScienceForPublicPolicy/diys/main/data/home_sales_nyc.csv">here</a>.</p>
<ul>
<li>Graph and regress sale price against gross square feet interpret the results</li>
</ul>
<pre class="r"><code>
sale_df &lt;- read_csv(&quot;https://raw.githubusercontent.com/DataScienceForPublicPolicy/diys/main/data/home_sales_nyc.csv&quot;)

ggplot(data = sale_df, aes(x = gross.square.feet, y = sale.price)) +
  geom_point(alpha = 0.15,
             size = 1.2,
             colour = &quot;blue&quot;) +
  scale_x_continuous(&quot;Property size (gross square feet)&quot;, labels = scales::comma) +
  scale_y_continuous(&quot;Sale price (USD)&quot;, labels = scales::comma) 

reg_est &lt;- lm(sale.price ~ gross.square.feet, data = sale_df)

summary(reg_est)</code></pre>
</div>
<div id="part-2" class="section level1">
<h1>Part 2</h1>
<p>Reproduce this figure from <a href="https://www.tmwr.org/base-r.html#tidiness-modeling">tidymodels 3.3</a>
<img src="images/corr-plot-1.svg" /> with the data from Part 1 replacing mpg with sale price for numeric variables.</p>
<pre class="r"><code>corr_res &lt;- map(sale_df %&gt;% select(where(is.numeric), -c(sale.price, borough, zip.code)), cor.test, y=sale_df$sale.price)
corr_res %&gt;% 
  map_dfr(broom::tidy, .id = &quot;predictor&quot;) %&gt;% 
  ggplot(aes(x = fct_reorder(predictor, estimate))) + 
  geom_point(aes(y = estimate)) + 
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = .1) +
  labs(x = NULL, y = &quot;Correlation with sale price&quot;) +
  theme_bw() +
  coord_flip()</code></pre>
</div>
<div id="part-3" class="section level1">
<h1>Part 3</h1>
<p>Exercise 7.4.5</p>
<p>Estimate a set of regressions, evaluate the pros and cons of each, and select the “best” specification.</p>
<p>Create and analyze the following four models from the textbook and one of your own:</p>
<ul>
<li>Model 1 (mod1) regresses sales prices and building area</li>
<li>Model 2 (mod2) adds borough as a categorical variable</li>
<li>Model 3 (mod3) incorporates an interaction to estimate borough-specific slopes for building area</li>
<li>Model 4 (mod4) adds land area</li>
</ul>
<pre class="r"><code>library(gridExtra)
# Simple regression
mod1 &lt;- lm(sale.price ~ gross.square.feet,
           data = sale_df)
# With borough
mod2 &lt;- lm(sale.price ~ gross.square.feet + factor(borough),
           data = sale_df)
# Interaction
mod3 &lt;- lm(sale.price ~ gross.square.feet * factor(borough),
           data = sale_df)
# With Additional variables
mod4 &lt;-
  lm(sale.price ~ gross.square.feet * factor(borough) + land.square.feet + age,
     data = sale_df)

sale_df &lt;- sale_df %&gt;% mutate(quarter = lubridate::floor_date(sale.date, &#39;quarter&#39;))

mod5 &lt;- lm(sale.price ~ gross.square.feet * factor(borough) + land.square.feet + age + factor(quarter),
     data = sale_df)

#Base
base1 &lt;-
  ggplot(sale_df, aes(x = gross.square.feet, y = sale.price / 1000000)) +
  geom_point(colour = rgb(0, 0, 0, 0.1), size = 0.8) +
  geom_point(
    aes(x = sale_df$gross.square.feet, y = predict(mod1) / 1000000),
    colour = rgb(1, 0, 0, 0.2),
    size = 0.6
  ) +
  xlab(&quot;Gross Square Feet&quot;) + ylab(&quot;Sales Price ($MM)&quot;) +
  ggtitle(paste0(&quot;Model 1 (BIC = &quot;, round(BIC(mod1)), &quot;)&quot;)) +
  xlim(0, 3000) + ylim(0, 3)

#Base2
base2 &lt;-
  ggplot(sale_df, aes(x = gross.square.feet, y = sale.price / 1000000)) +
  geom_point(colour = rgb(0, 0, 0, 0.1), size = 0.8) +
  geom_point(
    aes(x = sale_df$gross.square.feet, y = predict(mod2) / 1000000),
    colour = rgb(1, 0, 0, 0.2),
    size = 0.6
  ) +
  xlab(&quot;Gross Square Feet&quot;) + ylab(&quot;Sales Price ($MM)&quot;) +
  ggtitle(paste0(&quot;Model 2 (BIC = &quot;, round(BIC(mod2)), &quot;)&quot;)) +
  xlim(0, 3000) + ylim(0, 3)

#Base3
base3 &lt;-
  ggplot(sale_df, aes(x = gross.square.feet, y = sale.price / 1000000)) +
  geom_point(colour = rgb(0, 0, 0, 0.1), size = 0.8) +
  geom_point(
    aes(x = sale_df$gross.square.feet, y = predict(mod3) / 1000000),
    colour = rgb(1, 0, 0, 0.2),
    size = 0.6
  ) +
  xlab(&quot;Gross Square Feet&quot;) + ylab(&quot;Sales Price ($MM)&quot;) +
  ggtitle(paste0(&quot;Model 3 (BIC = &quot;, round(BIC(mod3)), &quot;)&quot;)) +
  xlim(0, 3000) + ylim(0, 3)

#Base4
base4 &lt;-
  ggplot(sale_df, aes(x = gross.square.feet, y = sale.price / 1000000)) +
  geom_point(colour = rgb(0, 0, 0, 0.1), size = 0.8) +
  geom_point(
    aes(x = sale_df$gross.square.feet, y = predict(mod4) / 1000000),
    colour = rgb(1, 0, 0, 0.2),
    size = 0.6
  ) +
  xlab(&quot;Gross Square Feet&quot;) + ylab(&quot;Sales Price ($MM)&quot;) +
  ggtitle(paste0(&quot;Model 4 (BIC = &quot;, round(BIC(mod4)), &quot;)&quot;)) +
  xlim(0, 3000) + ylim(0, 3)

grid.arrange(base1, base2, base3, base4, ncol = 2)

broom::glance(mod5)
broom::tidy(mod5)</code></pre>
</div>
<div id="part-4" class="section level1">
<h1>Part 4</h1>
<p>In the class divvy example (see the lectures page for code/files), we had a lot of missing values in our data. We also didn’t have a very rigorous treatment of time/seasonality. Explore how impactful these issues are by creating a few different models and comparing the predictions using the workflows we saw from class in parsnip, yardstick, and broom.</p>
<pre class="r"><code>divvy_data &lt;- read_csv(&#39;https://github.com/erhla/pa470spring2022/raw/main/static/lectures/week_3_data.csv&#39;)

grouped &lt;- rsample::initial_split(divvy_data)
train &lt;- training(grouped)
test  &lt;- testing(grouped)

lm_model &lt;-
  parsnip::linear_reg() %&gt;%
  set_engine(&quot;lm&quot;) %&gt;%
  set_mode(&#39;regression&#39;) %&gt;%
  fit(rides ~ solar_rad + factor(hour(started_hour)) + 
           factor(wday(started_hour)) +
           factor(month(started_hour)) +
           temp + wind + interval_rain + avg_speed, data=train)

preds &lt;- 
  predict(lm_model, test %&gt;% filter(month(started_hour) &gt;= 5)) 

test_preds &lt;- lm_model %&gt;% 
  augment(test %&gt;% filter(month(started_hour) &gt;=5))

yardstick::mape(test_preds, 
     truth = rides,
     estimate = .pred)
yardstick::rmse(test_preds, 
     truth = rides,
     estimate = .pred)

ggplot(test_preds, aes(x=.pred)) +
  geom_density()</code></pre>
<pre class="r"><code>divvy_data &lt;- divvy_data %&gt;%
  mutate(
    day = floor_date(started_hour, &#39;day&#39;),
    bad_weather = if_else(solar_rad &lt;= 5 &amp; temp &lt;= 5, 1, 0),
    nice_weather = if_else(solar_rad &gt;= 25 &amp; temp &gt;= 15, 1, 0)
  )

total_rain &lt;- divvy_data %&gt;% group_by(
  day
) %&gt;% summarize(total_precip = sum(interval_rain, na.rm=T))

divvy_data &lt;- divvy_data %&gt;% left_join(total_rain) %&gt;%
  mutate(rainy_weather = if_else(total_precip &gt; 0, 1, 0))

grouped &lt;- rsample::initial_split(divvy_data)
train &lt;- training(grouped)
test  &lt;- testing(grouped)

lm_model &lt;-
  parsnip::linear_reg() %&gt;%
  set_engine(&quot;lm&quot;) %&gt;%
  fit(rides ~ solar_rad + factor(hour(started_hour)) + 
        factor(nice_weather) + factor(bad_weather) + factor(rainy_weather) +
        temp + avg_speed, data=train)

preds &lt;- 
  predict(lm_model, test %&gt;% filter(month(started_hour) &gt;= 5)) 

test_preds &lt;- lm_model %&gt;% 
  augment(test %&gt;% filter(month(started_hour) &gt;=5))

yardstick::mape(test_preds, 
     truth = rides,
     estimate = .pred)
yardstick::rmse(test_preds, 
     truth = rides,
     estimate = .pred)

ggplot(test_preds, aes(x=.pred)) +
  geom_density()
</code></pre>
</div>
